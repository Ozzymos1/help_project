# help_project
 GIT training project (учебный проект)

## Основы работы с GIT

### Описание
**GIT** (*Global Information Tracker*) - это система контроля версий, которая помогает отслеживать изменения в программах (кодах), текстовых файлах, больших документах и т.д.
Она позволяет работать над одним проектом одновременно большому количеству людей (но также подходит и для одиночного использования).

Основными её функциями является:
- хранение истории изменений в виде отдельных ревизий;
- манипулирование историей (смена порядка ревизий, удаление версии, возврат к любой предыдущей версии);
- помощь в анализе изменений (кто и когда вносил изменения, кто чаще всего вносит изменения в определённый файл и т.д.).

### Использование
Изначально GIT является консольным приложением. Но существует множество GUI надстроек (графических). В системе Linux git уже встроена в ОС, а для Windows и MacOS 
её нужно устанавливать с официального сайта [GIT](https://git-scm.com/).

Но для начинающих наиболее удобны графические версии GIT (у приложения для Windows она встроена в установщик, на Linux нет), 
в первую очередь GitHub Desktop (позволяет работать с крупнейшим депозитарием [GitHub](https://github.com/)).

После установки нужно настроить GIT.

Это можно сделать в командной строке через команду ***git config***

опция *--global user.name "User Namovich"* определяет имя, которое будет определять участника команды (*имя или ник нужно написать латиницей и в кавычках*)

опция *--global user.email username@yandex.ru* определяет электронный почтовый ящик (*нужно указать свой настоящий email*).

В графической версии это сделать проще.

Далее необходимо определить какая папка на локальном диске будет репозиторием. 
В графической версии это делается через опцию создать репозиторий (каталог будет назван по имени репозитория и будет создан автоматически).
В консольной версии **нужно сначала создать каталог, а потом инициализировать его командой**  ***git init*** (при этом нужно находиться внутри каталога нового репозитория).
Начальная ветка называется **MAIN** (ранее она называлась **MASTER** и сейчас так тоже можно называть начальную ветку).

Если нужно удалить репозиторий (без удаления папки в файловой системе) в консольном режиме, то достаточно удалить подпапку **.git**.

Текущее состояние репозитория в консольном режиме проверяется командой **git status**.

Для того, чтобы отслеживать изменения в файлах, которые создаются в папке репозитория необходимо после их создания добавлять командой **git add** 
( ключ *--all* добавляет всё, что находится в папке, либо можно указать конкретный файл, который нужно добавить в репозиторий, либо вообще всю текущую папку если поставить точку после команды).
Также эта команда далее будет говорить, что файл готовы к сохранению в репозитории (фиксации их состояния или коммиту).

Коммит это одна из основных сущностей **GIT**, которая гарантирует сохранение изменений и позволяет при необходимости откатиться к предыдущим версиям. 
В консольной версии команда *git commit -m 'Описание коммита!'* позволяет сделать коммит с его описанием (оно помогает понять что было конкретно изменено).

История коммитов в консольной версии доступна через команду **git log**.

### Совместная работа или публичные репозитории
Если требуется совместная работа над проектом с другими людьми или он должен быть публичным (доступным для других людей), то необходимо использование специальных платформ. Самая известная из которых это **GitHub**.
Фактически это социальная сеть для разработчиков.

Для работы с этой платформой нужно зарегистрироваться на ней.

Далее необходимо связать свой локальный репозиторий с удалённым (на GitHub), но сначала, в целях безопасности, нужно создать ключ SSH и привязать его к платформе.
Для этого нужно с помощью специальной команды ***ssh-keygen -t ed25519 -C "электронная почта, к которой привязан аккаунт на GitHub"*** создать приватный и публичный ключ и в GitHub разместить публичный ключ.

SSH позволит решить две задачи - обеспечить шифрацию обмена данными с платформой и также дать защищённый доступ к репозиторию.

Связать локальный репозиторий с удалённым (на GitHub) можно с помощью команды **git remote add**, вот таким образом *git remote add origin git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ ПРОЕКТА%.git*. 
А команда **git remote -v** позволяет проверить, что репозитории связаны.

Изменения на удалённый репозиторий (после их коммитинга) направляются с помощью команда **git push**.
Но всё это проще делать в графической интерфейсе.

### Описание проекта
По умолчанию считается, что в каждом проекте должен быть файл **README.md** в котором даётся описание проекта (краткое, чтобы другие люди поняли что это за проект и для чего он). 
Также там описывают какие технологии используют в проекте, документацию, планы.

При этом используется специальный язык разметки Маркдаун (markdown), позволяющий отформатировать текстовый документ.

### Идентификатор коммита - это ХЭШ
Хэш - это отпечаток (*fingerprint*) некоторого файла (содержащейся в нём информации). 
В GIT используется алгоритм SHA-1, с его помощью преобразуется любое количество символов в строку из 40 символов (число в 16-тиричном формате).

Для одного и того же набора данных ХЭШ всегда будет гарантировано один и тот же. Но при изменении хотя бы одного символа ХЭШ гарантированно изменится.

Git хранит таблицу соответствий коммитов и их хэшей. Она хранится в каталоге .git и по хэшу всегда можно узнать дату коммита и его автора.

### Информация выдаваемая командой *LOG*
С помощью команды **git log** можно просмотреть информацию о коммитах (журнал записей коммитов).
Каждый коммит имеет свой хэш, далее отображается автор коммита, дата коммита, краткое название коммита и его описание.
Коммиты расположены в обратном порядке - первым отображается последний коммит.

С помощью команды **git log --oneline** можно посмотреть краткую версию журнала, в котором будет отображается несколько символов Хэша (достаточных для того, чтобы отличить коммиты друг от друга) и название коммита.

### HEAD (голова)
В файле .git/head записана ссылка на файл .git/refs/heads/main (или master) где содержится хэш последнего коммита который называют HEAD (голова). 
Т.е. для того, чтобы сослаться на последний коммит можно просто указать HEAD, т.е. не писать хэш последнего коммита, так как HEAD это синоним хэша последнего коммита.

### О статусе файлов в репозитории
Файлы в локальном каталоге репозитория могут находиться в 4-х статусах untracked, tracked, staged и modified.

Статус ***untracked*** (неотслеживаемый) имеют файлы, которые ещё не добавлены в репозитерий, но при этом находятся в локальном каталоге репозитория. Изменения в таких файлах не отслеживаются.

После включения файла в репозиторий, он получает статус ***tracked*** (отслеживаемый).

Это два взаимно исключающих состояния.

Отслеживаемые файлы могут иметь ещё два дополнительных состояния staged и modified. 

Состояние ***staged*** (подготовленный) файл получает после выполнения команды **git add**, когда он попадает в staging area
(в список файлов, которые войдут в коммит). Это состояние также называют индексированным или кэшированным.

Состояние ***modified*** (изменённый) означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. 
Например, файл был закоммичен и после этого изменён.

Важно - если файл был изменён после подготовки, то при коммите сохранится подготовленная версия файла. 
Т.е. файл одновременно может быть в состояниях staged и modified.

Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.

``` mermaid
  graph TD;
      A[untracked]-->|git add|B[tracked, staged];
      B-->|git commit|C[tracked];
      C-->|change file|D[modified];
      D-->|git add|B;
      B-->|change file|D;
```

Для того, чтобы понимать в каком статусе находятся сейчас файлы, чтобы закоммитить то, что нужно и не закоммитить то, что не нужно.
Для этого используется команда **git status**, которая показывает статусы:
- *staged* (Changes to be committed в выводе git status);
- *modified* (Changes not staged for commit);
- *untracked* (Untracked files).

Если в репозитории нет никаких изменений, то эта команда выдаст соответствующую информацию "*On branch master
nothing to commit, working tree clean*".

Если есть изменённые или неотслеживаемые файлы, то эта команда выдаст соответствующую информацию с подсказкой, 
что надо сделать чтобы поменять состояние файла (например, добавить файл в репозиторий). Если файл был изменён, но подготовлен к коммиту, то эта команда
также выдаст соответствующую информацию (что изменения не попадут в коммит и какую команду нужно применить, чтобы изменения попали в коммит 
либо что нужно применить команду для отмены изменений).

### Оформление сообщений к коммитам
При работе в команде следует договориться об общих правилах оформления сообщений к коммитам. Следование им позволит взаимодействовать более эффективно и упростить понимание кто, куда и зачем внёс в проект изменения.

В выводе команды **git log --oneline** умещается максимум 72 первых символа сообщения, 
поэтому многие правила включают пункт: «*Сообщение не должно быть длиннее 72 символов*».

Сообщения к коммитам помогают быстрее найти какие были сделаны изменения в том или ином коммите, 
или иначе, найти тот коммит, в котором были сделаны некие изменения, которые нас могут заинтересовать позже. 
Соответственно, одно из главных требований к сообщениям к коммитам - они должны быть полезными (информативными) 
и при этом относительно короткими (чтобы их можно было быстро прочитать).

Также при работе в команде требуется договориться о стиле комментариев, чтобы они были единообразны.
Один из самых популярных стилей оформления комментариев *Корпоративный* - поскольку в команиях используются системы для организации проектов и задач 
(например, Jira), то в сообщения для коммита включают идентификатор из нескольких заглавных латинских букв и номера, 
который соответствует задаче проекта, которую решаем. Это позволяет автоматически связывать коммиты с задачами и проектами.

Для проектов с исходным кодом программ используют стандарт *Conventional Commits* (соглашение о коммитах), 
который отличается качественной документацией и подробной проработкой. Он имеет формат *"type": "сообщение"*. 
*Type* - это тип изменений (feat - новая функциональность, fix - исправление ошибки и т.д.) 
Полное описание этого стиля находится на 
[сайте этого стандарта](https://www.conventionalcommits.org/ru/v1.0.0-beta.4/#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F).

Ещё одним возможным стилем является стиль *GitHub* который можно использовать не только для хранения файлов проекта, но и для ведения списка задач проекта.
Для этого в сообщении коммита необходимо поставить номер задачи, которую он закрывает (в стиле #45, ставить можно в любом месте сообщения).
В этом случае GitHub сам свяжет коммит и задачу.

Из негласных рекомендаций (сложившихся исторически) для сообщений на русском языке следует использовать инфинитивы (добавить, исправить, удалить и т.д.), 
а для английских сообщений следует использовать повелительное наклонение, т.е. императивы (use, fix и т.д.).

Ну и главное - все сообщения в проекте должны быть в ОДНОМ СТИЛЕ.

### Исправление коммитов
Для исправления коммитов у команды *git commit* есть опция *--amend* (исправить). 
Но она работает только с **последним коммитом**.
С помощью этой опции в последний коммит можно добавить "забытый" файл или 
файл, который дополнительно был изменён и его нужно добавить в последний коммит.
Если при этом использовать опцию  *--no-edit*, то при этом сообщение последнего коммита не будет изменено 
(только содержание).
Если же нужно изменит сообщение у последнего коммита, то нужно использовать опцию *-m* и далее новое сообщение.

### Откат изменений
Команда **git restore --staged "file"** позволяет убрать файл из состояния "подготовлен" (staged) 
в состояние неподготовлен (unstaged).

Если же требуется откатить коммит, то это делается командой **git reset --hard "commit hash"** ("суровый сброс").
После выполнения этой команды состояние репозитория вернётся к коммиту, указанному в ней. 
Т.е. он станет последним (HEAD) и все изменения, которые были после него будут удалены из репозитория.

Если же требуется удалить изменения, которые не попали ни в коммит ни в подготовленные, 
то для этого необходимо использовать команду **git restore "file"**. 
И тогда изменения в файле «откатятся» до последней версии, 
которая была сохранена через *git commit* или *git add*.

### Просмотр изменений в файлах репозитория.
Для этого необходимо использовать команду **git diff** (различие). 

Без параметров эта команда сравнит последнюю закоммиченную версию файла с его текущей (изменённой) версией. 
Красным цветом и знаком минус будут отмечены удалённые строки, 
а зелёным и знаком плюс которые были добавлены.
При этом в выводе команды будут указаны также номера изменённых строк.

Чтобы посмотреть изменения в подготовленных файлах нужно использовать команду с опцией **git diff --staged**.

Чтобы сравнить разные коммиты нужно использовать команду **git diff "commit1 hash" "commit2 hash"**.
По сути команда **git diff A B** выводит список инструкций: как превратить состояние A в состояние B. 
Если поменять A и B местами (**git diff B A**), то и инструкции будут обратные: как превратить B в A. 
При этом все зелёные строки станут красными, и наоборот.

### Шпаргалка по основам GIT
[Краткая шпаргалка по первой части куса](https://practicum.yandex.ru/trainer/git-basics/lesson/b1ecee27-bb78-46a0-8d13-0364c7803f55/) 

## Основы работы с ветками в GIT
GIT ценен, прежде всего, тем, что позволяет обеспечить взаимодействие команды.
- Он позволяет создавать клоны проектов для того, чтобы работать с ними локально, а потом синхронизировать с основным проектом. 
Либо чтобы вообще начать вести свой проект на основе уже существующего (делать fork).
- Он позволяет в рамках одного проекта создавать его разные ветки и работать с ними (что позволяет членам команды не мешать друг другу).
- Он позволяет объединять изменения в разных ветках проекта и разрешать возникающие при этом конфликты.
- Он позволяет после проверки этих изменений добавить их в основную ветку проекта.

### Клонирование репозитория
Клонирование существующих (например, на GitHub) репозиториев в локальный репозиторий осуществляется командой **git clone**.
В качестве параметра этой команде нужно передать адрес репозитория, который нужно клонировать. 
Например, *git clone https://github.com/yandex-praktikum/git-clone-lesson*.
При этом нужно находиться в той локальной директории, в которой планируется создание каталога с клонированным репозиторием.
При клонировании репозитория автоматически устанавливается связь локального репозитория с удалённым.
Проверка корректности клонирования и связи локального репозитория с удалённым осуществляется командой **git remote -v**.

### Ответвление (Fork) репозитория
На GitHub существует возможность создания копии какого-либо проект и её дальнейшее независимое от основного проект существование (в виде отдельного проекта).
Эта возможность называется Fork (ответвление)
Fork позволяет не только развивать собственный проект, но и сделать некие изменения (которые кажутся полезными) и далее предложить их для внесения в основной проект.
Чтобы создать Fork на GitHub требуется открыть основной проект (ответвление от которого планируется сделать) и нажать кнопку **Create fork**.
По умолчанию ответвление проекта будет названо также как и основной репозиторий. Далее это имя можно будет изменить.
После создания Fork, если требуется локальная работа с ним, нужно сделать клонирование этого репозитория.

### Ветки (branch)
**Ветка (branch)** — это изолированный поток разработки проекта (последовательность независимых от основной ветки изменений), 
в котором можно проверять разные идеи, тестировать новую функциональность и так далее.
При этом **основная ветка (main или master)** проекта остаётся в стабильном состоянии. 
Кроме того, ветки полезны для того, чтобы каждый член команды работал в своей ветке 
и не мешал другим пока его часть работы не будет сделана.
При работе в одиночку ветки полезны для работы над разными задачами.

Для просмотра веток используется команда **git branch**. При её вызове выдаётся список веток, которые имеются в проекте. 
Звёздочкой (**\***) отмечена ветка в которой мы находимся сейчас.

Для **создания ветки** имеется команда **git branch "название_ветки"**. 
Название ветки может состоять из букв, цифр, а также включать любой из четырёх символов: **., -, _, /**.
Названия веток должны быть информативными для других членов команды (и для себя тоже).
Как вариант, возможно именовать ветки по шаблону **"указатель ветки"/"имя ветки"**. 
Указатель *feature* (англ. «особенность», «деталь») для веток, где прорабатывается новая функциональность, 
указатель *bugfix* (от англ. bug — «жук», «ошибка» и fix — «исправить») для веток, где ведётся работа по исправлению ошибок, и т.д.

Для **переключения между ветками** имеется команда **git checkout "название_ветки"**. 
После переключения на ту или иную ветку все изменения в проекте сохраняются и коммитятся только в этой ветке и не затрагиваются информацию в других ветках.

Если требуется создать ветку и сразу начать с ней работать это делается предыдущей командой с ключом **-b** (*git checkout -b "название_ветки"*).

Ветка указывает на коммит, который сделан в ней последним. 
При этом две ветки могут ссылаться на один и тот же коммит — например, если только что создана ветка, но в неё ещё не внесён коммит.

### Сравнение веток
Сравнивать ветки можно той же командой, которой сравниваем коммиты - **git diff "название_ветки1" "название_ветки2"**.
При сравнении можно использовать название ветки и хеш коммита. 
Указанная показывает изменения, которые нужны, чтобы получить состояние ветки *"название_ветки2"* из *"название_ветки1"*.

Для удобства сравнивания коммитов команда *git diff* понимает суффикс навигации **~N**, где N — это число коммитов назад во времени (нумерация начинается с нуля). 
Например, *HEAD~1* — это следующий за текущим коммит (для первого коммита перед текущим единицу можно опустить и писать просто *HEAD~*).

### Объединение и удаление веток
Для объединения (иначе слияния) веток (как правило для добавления изменений в основную ветку проекта) используется команда **git merge "название_ветки"** 
(merge — «сливать», «поглощать»). **ВАЖНО** перед тем как начать процесс слияния, нужно перейти в ветку, куда должны добавиться изменения.

Если после слияния веток потребности в ней более не имеется, то для её удаления используется команда **git branch -D "название_ветки"**.
Вместо флага *-D* можно использовать более безопасный вариант - флаг *-d*. Он удалит ветку только если она была полностью объединена с другой. 
**ВАЖНО** удаление локальной ветки через Git не удаляет ветку на GitHub!

### Конфликты
Нередко сразу несколько членов команды работают над одним и тем же фрагментом проекта в разных ветках.
В том случае при слиянии могут происходить конфликты (это стандартная ситуации и в GIT есть механизм разрешения конфликтов). 

Если Git не может провести слияние изменений автоматически, он сообщает о конфликте. **Конфликт** — это ситуация, в которой один или несколько человек модифицировали один и тот же файл. При этом результаты таких модификаций оказались несовместимы и *разобраться в том, какой из вариантов правильный, **может только человек***.

**Общие рекомендации по разрешению конфликтов** (файлы, в которых произошёл конфликт GIT подсвечивает, если он не смог их объединить):
1. Заглянуть в файл, где произошёл конфликт.
2. Изучить обе стороны конфликта — вашу версию и версию вашего коллеги. Ваша задача — правильно собрать две версии в итоговую, так чтобы изменения обеих сторон не потерялись. Новая версия станет текущей актуальной.
3. Вручную удалить или подправить неактуальные изменения, если они есть.
4. Подготовить изменения к сохранению и сделать коммит.

### Работа с ветками в удалённом репозитории
Чтобы отправить локальную ветку на удалённый репозиторий сначала нужно её создать там (на вкладке *Repositories* нужно нажать кнопку *New*, далее ввести его название, сделать приватным или публичным и далее нажать на кнопку *Create repository*). 
После этого находясь основной ветке локального репозитория нужно связать локальный и удалённый репозитории. Делается это командой **git remote add origin git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ_РЕПОЗИТОРИЯ%.git**.
После этого нужно синхронизировать (запушить) локальный и удалённый репозитории (запушить). В первый раз это делается командой **git push -u origin main** (делать это нужно для каждой ветки, вместо main нужно вводить имя ветки). 
В дальнейшем для синхронизации репозиториев достаточно находясь в нужной ветке использовать команду **git push**.

Далее для того, чтобы можно было объединить в основной ветке проекта изменения, сделанные в своей ветке, требуется в удалённом репозитории (на GitHub в вебинтерфейсе) создать "запрос на изменения" (**pull request**). Такой запрос можно создать на любую ветку кроме *main*.
После этого при командной работе начинается процесс рассмотрения кода (**code review**).
У "запроса на изменения" есть "название", "описание", "исходная ветка", "целевая ветка" (ветка в которую нужно влить изменения). 
После заполнения этих полей требуется нажать кнопку **Create pull request**.
Каждый запрос имеет два итога (исхода). Либо слияние (**merge**), либо закрытие без слияния (**close**).
Решение об слиянии или закрытии запроса принимают после обсуждения на вкладке **Files changed** (у каждого "запроса на изменения" есть чаты, где команда может обсудить предлагаемые изменения). Там же можно добавить дополнительные коммиты перед слиянием веток.
Для того, чтобы изменения были слиты с главной веткой необходимо нажать кнопку **Merge pull request**. 
Для отклонения изменений необходимо нажать кнопку **Close pull request**. 
При этом далее можно будет вернуться к этому запросу, восстановить его и далее слить с основной веткой.

Для того, чтоб забрать изменения в удалённой ветке к себе в локальную используется команда **git pull** (вытянуть). 
Перед применением этой команды сначала надо перейти в терминале в нужную ветку локального репозитория. 
По хорошему это должна быть первая команда в начале работы с локальным репозиторием (несколько раз в день).
Также перед созданием пул-реквеста крайне желательно выполнять в локальной ветке с изменениями команды **git pull** и **git merge main** и лишь затем пушить её в удалённый репозиторий (**git push -u origin %ИМЯ_ВЕТКИ%**.
Если конечно при слиянии не было конфликтов. В противном случае их нужно сначала разрешить.

### Шпаргалка по работе с ветками и удалёнными репозиториями на GITHUB
[Краткая шпаргалка по второй части курса](https://practicum.yandex.ru/trainer/git-basics/lesson/f22bb418-0a08-4aa7-b937-e21cc77c9298/) 

## Продвинутая командная работа с Git
Реальные проекты создаются командами. Для командной работы важно заранее договаривориться о «правилах игры»: 
о структуре веток, об их роли в процессе, о принципах оформления коммитов и так далее.
И эти договорённости важно соблюдать.

### Состояние веток fast-forward 
Две ветки находятся в состоянии fast-forward, если одну из них можно «перемотать» вперёд и она будет содержать те же коммиты, что и другая.
Это означает, что при их слияниив принципе невозможен конфликт, их истории не разошлись, и одна ветка продолжает другую.
При выполнении команды **git merge %имя_сливаемой_ветки%** коммиты этой ветки подливаются в ветку **main** и обе ветки начинают содержать одинаковые коммиты. 
Т.е. ветка **main** перематывается до состояния сливаемой ветки.

При этом Fast-forward слияние веток можно отключить флагом *--no-ff* и тогда вместо перемотки ветки Git создаст коммит слияния.
Это часто делают для того, чтобы не терялась информация. При "перемотке" всё выглядит так, как будто всё делали в главной ветке.
А при отключении быстрого слияния остаётся история, что была дополнительная ветки и ряд коммитов были сделаны в ней.
Так как в этом случае создаётся полноценный коммит слияния, который сохраняет всю информацию (в т.ч. какая именно ветка вливалась в main).

## Состояние веток non-fast-forward
Это состояние веток, которые невозможно выстроить в одну цепочку и ветки содержат изменения в одних и тех же файлах.
Т.е. потенциально при слиянии этих веток возможен конфликт (одновременная попытка изменения одной и той же части проекта).
Собственно Git отслеживает именно вот эту потенциальную возможность конфликта, а не реальную.
При этом если конфликтов нет, то слияние будет произведено почти автоматически (вручную нужно будет ввести только коммит слияния,
но часто этого не делают, для чего используют команду с флагом **git merge --no-edit %имя_сливаемой_ветки%**.
Если же конфликты есть, то Git сначала попытается разрешить их автоматически. 
А если это не получится сделать, то Git предложит разрешить их вручную. 


