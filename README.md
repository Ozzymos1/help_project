# help_project
 GIT training project (учебный проект)

## Описание
**GIT** (*Global Information Tracker*) - это система контроля версий, которая помогает отслеживать изменения в программах (кодах), текстовых файлах, больших документах и т.д.
Она позволяет работать над одним проектом одновременно большому количеству людей (но также подходит и для одиночного использования).

Основными её функциями является:
- хранение истории изменений в виде отдельных ревизий;
- манипулирование историей (смена порядока ревизий, удаление версии, возврат к любой предыдущей версии);
- помощь в анализе изменений (кто и когда вносил изменения, кто чаще всего вносит изменения в определённый файл и т.д.).

## Использование
Изначально GIT явялется консольным приложением. Но существует множество GUI надстроек (графических). В системе Linux git уже встроена в ОС, а для Windows и MacOS 
её нужно устанавливать с официального сайта [GIT](https://git-scm.com/).

Но для начинающих наиболее удобны графические версии GIT (у приложения для Windows она встроена в установщик, на Linux нет), 
в первую очередь GitHub Desktop (позволяет работать с крупнейшим депозиторием [GitHub](https://github.com/)).

После установки нужно настроить GIT.

Это можно сделать в командной строке через команду ***git config***

опция *--global user.name "User Namovich"* определяет имя, которое будет определять участника команды (*имя или ник нужно написать латиницей и в кавычках*)

опция *--global user.email username@yandex.ru* определяет электронный почтовый ящик (*нужно указать свой настоящий email*).

В графической версии это сделать проще.

Далее необходимо определить какая папка на локальном диске будет репозиторием. 
В графической версии это делается через опцию создать репозиторий (каталог будет назван по имени репозитория и будет создан автоматически).
В консольной версии нужно сначала создать каталог, а потом инициализировать его командой  ***git init*** (при этом нужно находиться внутри каталога нового репозитория).
Начальная ветка назвается **MAIN** (ранее она называлась **MASTER** и сейчас так тоже можно называть начальную ветку).

Если нужно удалить репозиторий (без удаления папки в файловой системе) в консольном режиме, то достаточно удалить подпаку **.git**.

Текущее состояние репозитория в консольном режиме проверяется командой **git status**.

Для того, чтобы отслеживать изменения в файлах, которые создаются в папке репозитория необходимо после их создания добавлять командой **git add** 
( ключ *--all* добавляет всё, что находится в папке, либо можно указать конкретный файл, который нужно добавить в репозиторий, либо вообще всю текущую папку если поставить точку после команды).
Также эта команда далее будет говорить, что файл готовы к сохранению в репозитории (фиксации их состояния или коммиту).

Коммит это одна из основных сущностей **GIT**, которая гарантирует сохранение изменений и позволяет при необходимости откатиться к предыдущим версиям. 
В консольной версии команда *git commit -m 'Описание коммита!'* позволяет сделать коммит с его описанием (оно помогает понять что было конкретно изменено).

История коммитов в коносольной версии доступна через команду **git log**.

## Совместная работа или публичные репозитории
Если требуется совместная работа над проектом с другими людьми или он должен быть публичным (доступным для других людей), то необходимо использование специальных платформ. Самая известная из которых это **GitHub**.
Фактически это социальная сеть для разработчиков.

Для работы с этой платформой нужно зарегистрироваться на ней.

Далее необходимо связать свой локальный репозиторий с удалённым (на GitHub), но сначала, в целях безопасности, нужно создать ключ SSH и привязать его к платформе.
Для этого нужно с помощью специальной команды ***ssh-keygen -t ed25519 -C "электронная почта, к которой привязан аккаунт на GitHub"*** создать приватный и публичный ключ и в GitHub разместить публичный ключ.

SSH позволит решить две задачи - обеспечить шифрацию обмена данными с платформой и также дать защищённый доступ к репозиторию.

Связать локальный репозиторий с удалённым (на GitHub) можно с помощью команды **git remote add**, вот таким образом *git remote add origin git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ ПРОЕКТА%.git*. 
А команда **git remote -v** позволяет проверить, что репозитрии связаны.

Изменения на удалённый репозиторий (после их коммитинга) направляются с помощью команда **git push**.
Но всё это проще делать в графической интрефейсе.

## Описание проекта
По умолчанию считается, что в каждом проекте должен быть файл **README.md** в котором даётся описание проекта (краткое, чтобы другие люди поняли что это за проект и для чего он). 
Также там описывают какие технологии используют в проекте, документацию, планы.

При этом используется специальный язык разметки Маркдаун (markdown), позволяющий отформатировать текстовый документ.

## Идентификатор коммита - это ХЭШ
Хэш - это отпечаток (*fingerprint*) некоторого файла (содержащейся в нём информации). 
В GIT используется алгоритм SHA-1, с его помощью преобразуется любое количество символов в строку из 40 символов (число в 16-тиричном формате).

Для одного и того же набора данных ХЭШ всегда будет гарантировано один и тот же. Но при изменении хотя бы одного символа ХЭШ гарантированно изменится.

Git хранит таблицу соответствий коммитов и их хэшей. Она хранится в каталоге .git и по хэшу всегда можно узнать дату коммита и его автора.

## Информация выдаваемая командой *LOG*
С помощью команды **git log** можно просмотреть информацию о коммитах (журнал записей коммитов).
Каждый коммит имеет свой хэш, далее отображается автор коммита, дата коммита, краткое название коммита и его описание.
Коммиты расположенны в обратном порядке - первым отображается последний коммит.

С помощью команды **git log --oneline** можно посмотреть краткую версию журнала, в котором будет отображатеся несколько символов Хэша (достаточных для того, чтобы отличить коммиты друг от друга) и название коммита.

## HEAD (голова)
В файле .git/head записана ссылка на файл .git/refs/heads/main (или master) где содержится хэш последнего коммита который называют HEAD (голова). 
Т.е. для того, чтобы сослаться на последний коммит можно просто указать HEAD, т.е. не писать хэш последнего коммита, так как HEAD это синоним хэша последнего коммита.

## О статусе файлов в репозитории
Файлы в локальном каталоге репозитория могут находиться в 4-х статусах untracked, tracked, staged и modified.

Статус ***untracked*** (неотслеживаемый) имеют файлы, которые ещё не добавлены в репозитерий, но при этом находятся в локальном каталоге репозитория. Изменения в таких файлах не отслеживаются.

После включения файла в репозиторий, он получает статус ***tracked*** (отслеживаемый).

Это два взаимно исключающих состояния.

Отслеживаемые файлы могут иметь ещё два дополнительных состояния staged и modified. 

Состояние ***staged*** (подготовленный) файл получает после выполнения команды **git add**, когда он попадает в staging area
(в список файлов, которые войдут в коммит). Это состояние также называют индексированным или кэшированным.

Состояние ***modified*** (изменённый) означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. 
Например, файл был закоммичен и после этого изменён.

Важно - если файл был изменён после подготовки, то при коммите сохранится подготовленная версия файла. 
Т.е. файл одновременно может быть в состояниях staged и modified.

Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.

``` mermaid
  graph TD;
      A[untracked]-->|git add|B[tracked, staged];
      B-->|git commit|C[tracked];
      C-->|change file|D[modified];
      D-->|git add|B;
      B-->|change file|D;
```

Для того, чтобы понимать в каком статусе находятся сейчас файлы, чтобы закоммитить то, что нужно и не закоммитить то, что не нужно.
Для этого используется команда **git status**, которая показывает статусы:
- *staged* (Changes to be committed в выводе git status);
- *modified* (Changes not staged for commit);
- *untracked* (Untracked files).

Если в репозитории нет никаких изменений, то эта команда выдаст соответствующую информацию "*On branch master
nothing to commit, working tree clean*".

Если есть изменённые или неотслеживаемые файлы, то эта команда выдаст соответствующую информацию с подсказкой, 
что надо сделать чтобы поменять состояние файла (например, добавить файл в репозиторий). Если файл был изменён, но подготовлен к коммиту, то эта команда
также выдаст соответстующую информацию (что изменения не попадут в коммит и какую команду нужно применить, чтобы изменения попали в коммит 
либо что нужно применить команду для отмены изменений).

